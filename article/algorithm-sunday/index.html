<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sunday算法 | Hey sister</title>
<meta property='og:title' content='sunday算法 - Hey sister'>
<meta property='og:description' content='sunday算法是字符串模式匹配算法,是在BM算法上的优化.
提出者: Daniel M.Sunday(1990)
核心思想:在匹配过程中, 模式串并不被要求一定要按从左向右进行比较还是从右向左进行比较, 它在发现不匹配时, 算法能跳过尽可能多的字符以进行下一步的匹配, 从而提高了匹配效率.'>
<meta property='og:url' content='https://qbeenslee.com/article/algorithm-sunday/'>
<meta property='og:site_name' content='Hey sister'>
<meta property='og:type' content='article'><meta property='article:section' content='Article'><meta property='article:tag' content='algorithm'><meta property='article:tag' content='sunday'><meta property='article:tag' content='字符串'><meta property='article:tag' content='匹配'><meta property='article:published_time' content='2013-11-17T00:22:43&#43;08:00'/><meta property='article:modified_time' content='2013-11-17T00:22:43&#43;08:00'/><meta name='twitter:card' content='summary'><meta name='twitter:site' content='@'><meta name='twitter:creator' content='@'>

<link href="https://qbeenslee.com/index.xml" rel="alternate" type="application/rss+xml" title="Hey sister" />

<link rel="stylesheet" href="/css/style.css"/><link rel='stylesheet' href='https://qbeenslee.com/css/custom.css'><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
<script src="/js/jquery.min.js" type="text/javascript"></script>

<script type="text/javascript" src="/js/leaflet.js"></script>
<link rel="stylesheet" href="/css/leaflet.css"/>
</head>
<body>

<div id="header" class="auto_header noselect" style="transition: top 0.3s ease-in-out; top: 0px; position: fixed; z-index: 9999;">
    
    <div class="site"><a href="/"><div class="title">Hey sister</div></a>
    </div>
    <div id="nav-bar">
        
        
        
        
        
        <nav class="nav-item level is-mobile">
            
            <a href="/gallery/" class="nav-color-normal">相册</a>
            
        </nav>
        
        
        
        <nav class="nav-item level is-mobile">
            
            <a href="/bb/" class="nav-color-normal">小声BB</a>
            
        </nav>
        
        
        
        <nav class="nav-item level is-mobile">
            
            <a href="/about/" class="nav-color-normal">关于</a>
            
        </nav>
        
        
    </div>
</div>

<section class="section-content">
  <div class="container">
    <h1 class="title">sunday算法</h1>
    <span class="subtitle">2013年11月17日 00:22</span>
    
    <div class="content">
      <p>sunday算法是字符串模式匹配算法,是在BM算法上的优化.<br />
<strong>提出者</strong>: Daniel M.Sunday(1990)<br />
<strong>核心思想</strong>:在匹配过程中, 模式串并不被要求一定要按从左向右进行比较还是从右向左进行比较, 它在发现不匹配时, 算法能跳过尽可能多的字符以进行下一步的匹配, 从而提高了匹配效率.</p>

<p><strong>简单匹配过程</strong>:<br />
文本为:&ldquo;substring searching algorithm&rdquo;<br />
字串为:&ldquo;search&rdquo;<br />
刚开始时, 把子串与文本左边对齐:<br />
substring searching algorithm<br />
search<br />
结果在第二个字符处发现不匹配, 于是要把子串往后移动. 但是该移动多少呢？<br />
这就是各种算法各显神通的地方了, 最简单的做法是移动一个字符位置;<br />
KMP是利用已经匹配部分的信息来移动;<br />
BM算法是做反向比较, 并根据已经匹配的部分来确定移动量.<br />
这里要介绍的方法是看紧跟在当前子串之后的那个字符 （第一个字符串中的&rsquo;i&rsquo;).<br />
显然, 不管移动多少, 这个字符是肯定要参加下一步的比较的.<br />
也就是说, 如果下一步匹配到了, 这个字符必须在子串内.<br />
所以, 可以移动子串, 使子串中的最右边的这个字符与它对齐. 现在子串&rsquo;search&rsquo;中并不存在&rsquo;i&rsquo;, 则说明可以直接跳过一大片, 从&rsquo;i&rsquo;之后的那个字符开始作下一步的比较, 如下:<br />
substring searching algorithm<br />
search<br />
比较的结果, 第一个字符就不匹配, 再看子串后面的那个字符, 是&rsquo;r&rsquo;,它在子<br />
串中出现在倒数第三位, 于是把子串向后移动三位, 使两个&rsquo;r&rsquo;对齐, 如下:<br />
substring searching algorithm<br />
search<br />
这次匹配成功了！<br />
上面一段例子摘自:<a href="http://blog.chinaunix.net/uid-25513153-id-225240.html" target="_blank">http://blog.chinaunix.net/uid-25513153-id-225240.html</a><br />
C语言实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*************************** 
</span><span class="cm">sunday algorithm
</span><span class="cm">By: QbeensLee
</span><span class="cm">Date:2013/11/17
</span><span class="cm">****************************/</span>
<span class="cp">#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp">#define LIMITED 1000000
</span><span class="cp"></span><span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="n">LIMITED</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="n">LIMITED</span><span class="p">];</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sunday</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">))</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">tag</span><span class="p">,</span><span class="n">size_match</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">limit</span><span class="p">,</span><span class="n">shift</span><span class="p">[</span><span class="mi">256</span><span class="p">],</span><span class="n">len_text</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">text</span><span class="p">),</span><span class="n">len_key</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">key</span><span class="p">);</span> 
	<span class="k">if</span><span class="p">(</span><span class="n">len_key</span><span class="o">&gt;</span><span class="n">len_text</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">256</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">len_key</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len_key</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">shift</span><span class="p">[</span><span class="o">*</span><span class="p">(</span><span class="n">key</span><span class="o">+</span><span class="n">i</span><span class="p">)]</span><span class="o">=</span><span class="n">len_key</span><span class="o">-</span><span class="n">i</span><span class="p">;</span>
	<span class="n">limit</span><span class="o">=</span><span class="n">len_text</span><span class="o">-</span><span class="n">len_key</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">limit</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="n">shift</span><span class="p">[</span><span class="n">text</span><span class="p">[</span><span class="n">len_key</span><span class="o">+</span><span class="n">i</span><span class="p">]])</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">text</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">==*</span><span class="n">key</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">match</span><span class="o">=</span><span class="n">text</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">size_match</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">do</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">size_match</span><span class="o">==</span><span class="n">len_key</span><span class="p">)</span>
					<span class="n">ans</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span><span class="k">while</span><span class="p">((</span><span class="o">*</span><span class="n">match</span><span class="o">++</span><span class="p">)</span><span class="o">==</span><span class="n">key</span><span class="p">[</span><span class="n">size_match</span><span class="o">++</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//freopen(&#34;a.in&#34;,&#34;r&#34;,stdin);
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%*c&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">gets</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
		<span class="n">gets</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">sunday</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span></code></pre></div>
<p>但在ACM的OJ上, 实用sunday算法成功解决KMP算法是不太容易的,往往会超时, 这因为这些题目摆明了是要用KMP算法做的.</p>

<p>KMP比较适合在文本中大量重复出现子串的匹配, So~ ~ OJ上的测试数据都是对KMP算法有利.</p>

<p>但在实用性和易懂性上讲,我还是比较喜欢sunday算法的.</p>

<p>推荐阅读:</p>

<p><a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/sundayen.htm" target="_blank">Sunday algorithm</a></p>

<p><a href="http://www-igm.univ-mlv.fr/~lecroq/string/node19.html" target="_blank">Quick Search algorithm</a></p>

<p><a href="http://d.wanfangdata.com.cn/periodical_jsjgc200907042.aspx" target="_blank">改进的Sunday模式匹配算法</a></p>
      
    </div>
    
  </div>
</section>




<style>
    #vcomments .info {display: none !important;}
    .vhead, .vheader{display: none !important;}
    .v .vlist .vcard{padding-top: 0 !important;}
    .v code, .v pre{font-size:100% !important;}
</style>
<section class="section-content noselect">
    <div id="vcomments"  class="container"></div>
</section>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
new Valine({
    el:'#vcomments',
    appId:'G3MMP8E4DNTqvCPV48o7Ph23-gzGzoHsz',
    appKey:'jYCgILtFpGK1vJUJSE5TtIIs',
    notify:false, 
    verify:false, 
    avatar:'hide', 
    placeholder: '随便说点啥, 反正没人知道你是谁呀~~' 
});
</script>








<section class="section site_footer_grap noselect">
  <div class="container has-text-centered">
    <p>&copy; Qbeenslee 2019</p>
  </div>
</section>
</body>
<script type="text/javascript" src="/js/auto_header.js"></script>
</html>

