<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>Android网络框架封装的认知 | Hey sister</title><meta name="description" content="在开发应用中网络模块是项目中很重要和复杂的一部分. 从零开始写一个网络请求框架是一件吃力不讨好的事情, 也有重复造轮子的嫌疑. github上有很多优秀的开源网络请求框架例如: retrofit ok"><meta name="keywords" content="android,网络框架,封装"><meta name="author" content="qbeenslee"><meta name="msapplication-TileColor" content="#ffffff"><meta name="theme-color" content="#ffffff"><meta property="config" content="protectImage,list"><meta property="og:title" content="Android网络框架封装的认知 | Hey sister"><meta property="og:description" content="在开发应用中网络模块是项目中很重要和复杂的一部分. 从零开始写一个网络请求框架是一件吃力不讨好的事情, 也有重复造轮子的嫌疑. github上有很多优秀的开源网络请求框架例如: retrofit ok"><meta property="og:url" content="https://qbeenslee.com/article/thinking-of-net-framework-on-android/"><meta property="og:site_name" content="Hey sister"><meta property="og:type" content="article"><meta property="article:section" content="Article"><meta property="article:tag" content="android"><meta property="article:tag" content="网络框架"><meta property="article:tag" content="封装"><meta property="article:published_time" content="2015-10-27T15:04:09&#43;08:00"><meta property="article:modified_time" content="2015-10-27T15:04:09&#43;08:00"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@"><link rel="alternate" type="application/rss+xml" title="Hey sister" href="https://qbeenslee.com/index.xml"><link rel="stylesheet" href="https://qbeenslee.com/css/main-1896502045.css"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><script src="https://qbeenslee.com/js/darkmode-09dcfb2235.js" type="text/javascript"></script><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js" type="text/javascript"></script><script src="https://cdn.bootcdn.net/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js" type="text/javascript"></script></head><body style="background-color:#fff"><header id="header" class="auto_header unselectable nav-opaque" style="top:0;position:fixed;z-index:1100"><div class="nav-left"><nav><div class="logo nav-item"><a class="nav-with-shadow nav-color-subject" href="/">Hey sister</a></div><div class="nav-item"> <a class="nav-color-normal" href="/bb/">小声BB</a></div><div class="nav-item dropdown"> <a class="dropbtn nav-color-normal">归档<span class="caret"></span></a><div class="dropdown-content"> <a href="/archives/">全部</a><a href="/categories/">类目</a><a href="/tags/">标签</a></div></div><div class="nav-item dropdown"> <a class="dropbtn nav-color-normal">关于<span class="caret"></span></a><div class="dropdown-content"> <a href="/about/me/">关于我</a><a href="/friends/">友情链接</a><a href="/about/website/">技术说明</a><a href="/copyright/">版权声明</a><a href="/privacy/">隐私条款</a><a href="/index.xml">订阅</a></div></div></nav></div><div class="nav-right"><div class="nav-item" title="夜晚模式"><div class="nav-with-shadow nav-color-subject"><i onclick="toggleDarkmode()" class="icon large" id="darkmode-switcher"></i></div></div><div class="nav-item" title="搜索"><div class="search-button nav-with-shadow nav-color-subject"><i onclick="toggleSearch()" class="icon large search"></i></div><div class="search-box"><div class="search"><div class="input"> <input class="prompt" maxlength="1000" autocomplete="off" type="text" placeholder="搜索"></div><div class="results"></div></div></div></div></div></header><main class="page" id="save-article-as-img"><div id="page"><div class="horizontal-safe vertical-safe"><div class="page-wrapper"><div class="middle-side"><article><div class="article-header"><h1 class="title">Android网络框架封装的认知</h1> <span class="subtitle">2015年10月27日 15:04</span></div><div class="content" id="content"><p>在开发应用中网络模块是项目中很重要和复杂的一部分. 从零开始写一个网络请求框架是一件吃力不讨好的事情, 也有重复造轮子的嫌疑. github上有很多优秀的开源网络请求框架例如:</p><ul><li><a href="https://github.com/square/retrofit" target="_blank">retrofit</a></li><li><a href="https://github.com/square/okhttp" target="_blank">okhttp</a></li><li><a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank">volley</a></li></ul><p>我们需要在这些第三方框架的基础上再封装, 目的是为了实现: 统一处理, 简化调度. 下面就是年青人对网络框架封装一些粗鄙的认知.</p><h3 id="1对外调用接口统一">1.对外调用接口统一</h3><p>项目快速的开发过程中没有认真做框架选型调研, 在后期开发中随着框架不足的暴露, 迫使开发者去使用新的框架. 但替换旧框架的过程肯定是异常艰辛的, 所以有必要在前期就封装一套统一稳健的对外调用接口.</p><p>这有点类似于BaseActivity的作用, 其实可以理解这层封装是一个<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" target="_blank">代理模式</a>. 实现过程可以更粗暴, 直接将逻辑代码写在调用类中, 如果要替换新的新的网络框架也是粗暴重写.</p><p>对外调用方式封装可以按开发者喜好来, 比如我比较喜欢链式编程, 那我可以构建一个<a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank">Fluent interface</a>.</p><div class="highlight"><pre tabindex="0" class="chroma code-java"><div class="prefix"></div><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Query</span><span class="o">.</span><span class="na">api</span><span class="o">(</span><span class="n">api</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">     <span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">     <span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">file</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">     <span class="o">.</span><span class="na">post</span><span class="o">(</span><span class="k">new</span> <span class="n">Query</span><span class="o">.</span><span class="na">OnQuery</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailed</span><span class="o">(</span><span class="n">Error</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            	<span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">Model</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            	<span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">}</span>
</span></span><span class="line"><span class="cl">     <span class="o">});</span>
</span></span></code></pre></div><h3 id="2数据解析和业务实现抽离">2.数据解析和业务实现抽离</h3><p>老是听到程序员抱怨产品改需求(说的就是我自己), 产品改需求就会在一定程度上实地程序员的辛苦变成徒劳. 也不尽然, 需求的改变更多的是发生在业务逻辑和页面实现上, 但服务器接口是相对稳定的, 所以可以将数据解析单独抽离出来. 在一个单独的类中实现数据解析封装, 这样即符合单一职责原则(<a href="https://zh.wikipedia.org/zh-cn/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank">SRP</a>)也可以实现代码重用(<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank">DRY</a>).</p><p>还有在面临的解析的数据是多层级多广度的, 而在网络请求做解析抽离后只能返回单个对象时, 可以在解析时组装业务层需要的Bean(业务)实例并返回. 当解析数据容量很大或者需要做数据缓存等耗时操作需要将整个过程异步处理, 然后再返回给UI线程. <em>永远不要相信服务器不会挂</em>, 就算是服务器挂了我们客户端也要接住掉下来的锅. 不要服务器数据返回数据一有问题客户端就挂了. 所以要在解析过程中做异常处理或者添加数据校验.</p><p>关于数据实体类, 我见到的大部分的项目中实体类中有很多get/set的方法，很没有必要. 一是浪费人力(虽然Android Studio可以自动生成代码), 二是新增性能消耗. 在开发中大部分的实体类只是为了读取一下数值, 完全没有必要添加访问控制(真的需要时可以酌情使用), 推荐直接使用public暴露出来(具体可以查看google给出的<a href="http://developer.android.com/training/articles/perf-tips.html#GettersSetters" target="_blank">建议</a>).</p><p>这里给出一种外部调用的范例:</p><p><strong>解析类</strong></p><div class="highlight"><pre tabindex="0" class="chroma code-java"><div class="prefix"></div><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 登录信息解析类, 包括绑定接口(api)和数据解析(parse)
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoginQuery</span> <span class="kd">extends</span> <span class="n">Query</span><span class="o">&lt;</span><span class="n">LoginModel</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">api</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;this.is.request.api&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="n">LoginModel</span> <span class="nf">parse</span><span class="o">(</span><span class="n">String</span> <span class="n">rawJsonData</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isFailure</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">parseJson</span><span class="o">(</span><span class="n">rawJsonData</span><span class="o">,</span> <span class="n">LoginModel</span><span class="o">.</span><span class="na">class</span><span class="o">);</span><span class="c1">//这是解析过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>数据模型</strong></p><div class="highlight"><pre tabindex="0" class="chroma code-java"><div class="prefix"></div><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 登录接口返回数据模型
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoginModel</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">    * 如果服务端字段定义不符合java规范
</span></span></span><span class="line"><span class="cl"><span class="cm">    * 或者工程要代码混淆时可以使用Gson注解控制
</span></span></span><span class="line"><span class="cl"><span class="cm">    **/</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@SerializedName</span><span class="o">(</span><span class="s">&#34;user_name&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="n">userName</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@SerializedName</span><span class="o">(</span><span class="s">&#34;user_id&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="n">userId</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@SerializedName</span><span class="o">(</span><span class="s">&#34;access_token&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="n">accessToken</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><strong>调用</strong></p><div class="highlight"><pre tabindex="0" class="chroma code-java"><div class="prefix"></div><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* 返回的数据类型有泛型约束
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="n">LoginQuery</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">context</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span><span class="n">value</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">.</span><span class="na">post</span><span class="o">(</span><span class="k">new</span> <span class="n">Query</span><span class="o">.</span><span class="na">Callback</span><span class="o">&lt;</span><span class="n">LoginModel</span><span class="o">&gt;(){</span>
</span></span><span class="line"><span class="cl">          	<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailed</span><span class="o">(</span><span class="n">Error</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            	<span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">LoginModel</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            	<span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">}</span>
</span></span><span class="line"><span class="cl">          <span class="o">});</span>
</span></span></code></pre></div><h3 id="3规范">3.规范</h3><p>规范是个好事, 最好还是在做事情之前就定好了(就开发而言).</p><p>对于http接口的一些规范, 就是数据包规范. 比如: 接口API要拼接在url里; request parameter body里面就好就只存在和业务相关的请求参数, 其他基础数据可以放在header中.</p><p>还有就是千万不要在Fragment的<code>onCreate()</code>中发起网络请求, 一般认为网络请求消耗的时间是会远远大于界面绘制的时间. 然后在网络请求返回时以为视图已经初始化完成, 但真的能保证吗?如果我在封装架构里添加一层网络状态检查, 没有网络就直接回调. 接下来会发生什么, 就看个人修养了. 另外提醒一下, 如果是在Fragment里发起的网络请求在回调回来之后最好要做生命周期判断, 否则有可能报<code>IllegalStateException</code>异常.</p><div class="highlight"><pre tabindex="0" class="chroma code-java"><div class="prefix"></div><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">new</span> <span class="n">Query</span><span class="o">.</span><span class="na">Callback</span><span class="o">&lt;</span><span class="n">LoginModel</span><span class="o">&gt;(){</span>
</span></span><span class="line"><span class="cl">              <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailed</span><span class="o">(</span><span class="n">Error</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">LoginModel</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">               <span class="kd">final</span> <span class="n">Activity</span> <span class="n">activity</span> <span class="o">=</span> <span class="n">getActivity</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">               <span class="k">if</span> <span class="o">(</span><span class="n">activity</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">activity</span><span class="o">.</span><span class="na">isFinishing</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">              	<span class="c1">//页面没有被回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               	<span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span></code></pre></div><blockquote><p>ps: 外部调用我都想好了, 谁来写内部实现呢(算了近期我打算自己去实现一个) &hellip;</p></blockquote><blockquote><p>pps: 毕竟是年青人, 说得不好的要给他指出来.</p></blockquote><hr><p>20160415更新:</p><p>网络库封装地址: <a href="https://github.com/qbeenslee/http-query" target="_blank">http-query</a></p></div><div class="related"><h2 class="see-also">关联阅读<ul><li><a href="/article/rxjava-custom-operator-with-bracode-gun/">Rxjava自定义操作符与扫码枪</a></li><li><a href="/article/building-an-android-hotfix-architecture/">Android热修复架构杂谈</a></li><li><a href="/article/android-webview-302-redirect/">Android WebView内处理302重定向</a></li><li><a href="/article/about-wandoujia-proguard-config/">豌豆荚Android混淆字典, 眼睛要瞎了</a></li><li><a href="/article/super-simple-android-adapter-pattern/">一种简洁的Adapter模式实现</a></li></ul></h2></div></article></div></div><div class="comment-wrap unselectable"><style>#vcomments .info,.at,.vcontent>a[href^="#"],.vcopy,.vlink,.vpower,.vsys{display:none!important}#vcomments{color:var(--text)}.v .vlist .vcard{padding-top:0!important}.v code,.v pre{font-size:100%!important}.vinput{border:none!important}.vheader{border-bottom:1px dashed var(--border-divide)!important}.v[data-class=v] .vwrap{border:1px solid var(--border-divide)!important}</style><section class="section-content unselectable"><div id="vcomments" class="container"></div></section><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",lang:"zh-cn",appId:"G3MMP8E4DNTqvCPV48o7Ph23-gzGzoHsz",appKey:"jYCgILtFpGK1vJUJSE5TtIIs",notify:!1,verify:!1,avatar:"hide",visitor:!1,recordIP:!1,placeholder:"随便说点啥~~"})</script></div></div></div></main><footer class="site_footer_grap unselectable"><div class="has-text-centered"><p>&copy;Qbeenslee 2022</p></div></footer><script type="text/javascript" src="https://qbeenslee.com/js/main-7d91c3f6b6.js"></script><script async type="text/javascript" src="https://hm.baidu.com/hm.js?58b3c65a09f5aacd0e62efe29897c7e4"></script></body></html>